# 🖥️ Data

<br>

## 정보 단위
- 컴퓨터는 **0 또는 1**만 이해할 수 있고 이를 **비트(bit)** 라고 한다.
- 컴퓨터는 **0 = 전류 흐름 있음, 1 = 전류 흐름 없음** 즉 전기 신호만 처리한다.  
 👉🏻 [비트로 표현 가능한 정보의 수](#bit)
- 이외 정보 단위  
    |명칭|크기|
    |--|--|
    |1바이트(1byte)|8비트(8bit)|
    |1킬로바이트(1kB)|1,000바이트(1,000byte)|
    |1메가바이트(1MB)|1,000킬로바이트(1,000kB)|
    |1기가바이트(1GB)|1,000메가바이트(1,000MB)|
    |1테라바이트(1TB)|1,000기가바이트(1,000GB)  
    <details>
    <summary> 💡 알아 두면 좋은 정보 단위</summary>

    ### 워드(word)
    **CPU가 한번에 처리할 수 있는 데이터 크기** CPU 아키텍처마다 워드 크기가 다르다.
    - x86 (32bit) CPU 기준

        |비트 단위|워드 단위|
        |--|--|
        |16bit|하프 워드(half word)|
        |32bit|풀 워드(full word)|
        |64bit|더블 워드(double word)|  

    - x64 (64bit) CPU 기준
        |비트 단위|워드 단위|
        |--|--|
        |32bit|하프 워드(half word)|
        |64bit|풀 워드(full word)|
        |128bit|더블 워드(double word)|    
        > 즉 CPU가 한번에 가져와서 계산 할 수 있는 **기본 처리 단위.**

    </details>

<br>

## 진법
### 이진법
- **0과 1**로 숫자를 표현하는 방법
- 숫자가 **1을 넘어가는 시점에 자리올림**이 발생함.

    |십진수|이진수|
    |--|--:|
    |1|0|
    |2|01|
    |3|11|
    |4|100|
    |5|101|
    |6|110|
    |7|111|
    |8|1000|

    <details>
    <summary> 💡 10진수를 2진수로 변환하는 팁</summary>  

    - 10진수  67을 2진수로

        |128|64|32|16|8|4|2|1|
        |:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
        |0|1|0|0|0|0|1|1|  
    - 10진수  88을 2진수로

        |128|64|32|16|8|4|2|1|
        |:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
        |0|1|0|1|1|0|0|0|         
        > $2^n$의 수끼리 더했을 때 구하고자 하는 10진수 값이 나오는 값에 1(켜짐)을 줌

    </details>

<br>

- 2진수 끝에 **아래첨자**나 앞에 **0b**를 붙여 이진수임을 구분한다.
    <details>
    <summary> 💡 예시</summary>  

    >ex) 1000<sub>(2)</sub>  
     ex) 0b1000

    </details>

<br>

### 이진수의 음수 표현
- 컴퓨터는 0과 1만 이해할 수 있기 때문에 - 와 같은 부호는 인식 불가능
- 따라서 **2의 보수(two's complement)** 를 구해 이 값을 **음수로 인식**한다.  
    👉🏻 [2의 보수의 사전적 개념](#two's_complement)
- 단순히 **모든 1과 0을 뒤집고** 거기에 **1을 더한 값**으로 간단히 계산할 수 있다.
    <details>
    <summary> 💡 예시</summary>  

    <br>

    101<sub>(2)</sub> 를 음수(2의 보수)로 표현하기

    |8|4|2|1|
    |--|--|--|--|
    |0|1|0|1| 

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬇ 모든 0과 1을 뒤집기

    |8|4|2|1|
    |--|--|--|--|
    |1|0|1|0|

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬇ 1 더하기

    |8|4|2|1|
    |--|--|--|--|
    |1|0|1|1|
    
    101<sub>(2)</sub> 를 음수(2의 보수)로 표현한 값

    </details>

- **2의 보수가 적용된 값에 2의 보수를 다시한번 적용**하면 원래 형태로 돌아온다.
    <details>
    <summary> 💡 예시</summary>  

    <br>

    2의 보수가 적용된 101<sub>(2)</sub>

    |8|4|2|1|
    |--|--|--|--|
    |1|0|1|1| 

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬇ 모든 0과 1을 뒤집기

    |8|4|2|1|
    |--|--|--|--|
    |0|1|0|0|

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬇ 1 더하기

    |8|4|2|1|
    |--|--|--|--|
    |0|1|0|1|
    
    101<sub>(2)</sub> (양수)로 복귀

    </details>

- 컴퓨터는 **양수인지 음수인지 구분을 위해 플래그(flag)를 사용**한다.

<br>

### 십육진법
- 십진법 **15를 넘어가는 시점에서 자리올림**을 하는 숫자 표현 방법.  

    |십육진수|0|1|...|9|A|B|C|D|E|F|10|11|...|
    |--|--|--|--|--|--|--|--|--|--|--|--|--|--|
    |십진수|0|1|...|9|10|11|12|13|14|15|16|17|...|

- 2진수 끝에 **아래첨자**나 앞에 **0x**를 붙여 이진수임을 구분한다.
    <details>
    <summary> 💡 예시</summary>  

    >ex) 15<sub>(16)</sub>  
     ex) 0x15

    </details>

- 십육진수를 사용하는 이유는 이진수와 변환하는 과정이 쉽기 때문이다.
    <details>
    <summary> 💡 16진수를 2진수로 변환하는 팁</summary>  

    - 16진수  1A2B을 2진수로  

        - 1  
            |8|4|2|1|
            |--|--|--|--|
            |0|0|0|1|
        - A  
            |8|4|2|1|
            |--|--|--|--|
            |1|0|1|0|
        - 2  
            |8|4|2|1|
            |--|--|--|--|
            |0|0|1|0|
        - B  
            |8|4|2|1|
            |--|--|--|--|
            |1|0|1|1|

        > 1A2B<sub>(16)</sub> = 1101000101011<sub>(2)</sub>

    </details>



<br>
<br>
<br>
<br>
<br>
<br>

## 보충 이론

### <span id="bit">비트로 표현 가능한 정보의 수</span>
- 2bit인 경우  
    |bit|bit|
    |--|--|
    |0|0|
    |0|1|
    |1|0|
    |1|1|

    총 4개의 경우의 수 발생  

<br>

- 3bit인 경우
    |bit|bit|bit|
    |--|--|--|
    |0|0|0|
    |1|0|0|
    |0|1|0|
    |0|0|1|
    |1|1|0|
    |1|0|1|
    |0|1|1|
    |1|1|1|

    총 8개의 경우의 수 발생  

    > 위 규칙으로 컴퓨터가 인식 가능한 0과 1(고정값 2), 비트의 개수(0과 1을 담는 공간)만큼이 지수로서 계산되어 경우의 수 가 발생한다. 이를 수학식으로 **$2^n$** 라고 표현할 수 있다.
    <details>
    <summary>위 공식을 적용해보자</summary>

    |비트 수|공식|표현 가능한 정보 수|
    |--|--|--|
    |4bit|$2^4$|16개|
    |5bit|$2^5$|32개|
    |6bit|$2^6$|64개|
    |7bit|$2^7$|128개|
    |8bit|$2^8$|256개|
    
    </details>

<br>

### <span id="two's_complement">2의 보수의 사전적 개념</span>
- '어떤 수를 그보다 큰 2<sup>n</sup>에서 뺀 값'
    > ex) 11<sub>(2)</sub>의 2의 보수는 11<sub>(2)</sub>보다 큰 2<sup>n</sup> 100<sub>(2)</sub>에서 11<sub>(2)</sub>를 뺀 01<sub>(2)</sub>가 된다.  

    - 11<sub>(2)</sub>보다 큰 2<sup>n</sup> = 100<sub>(2)</sub>  
        |8|4|2|1|
        |--|--|--|--|
        |0|1|0|0|  

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⬇ 100<sub>(2)</sub> - 11<sub>(2)</sub>

        |8|4|2|1|
        |--|--|--|--|
        |0|0|0|1|  

        11<sub>(2)</sub>를 음수로 표현한 값 01<sub>(2)</sub>
